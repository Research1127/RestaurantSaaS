# Claim Based Access Control

## Purpose of Claim-Based Access Control

Claim-based access control allows the system to authorize users based on specific attributes stored inside their authentication token.

By using policies, authorization rules can be centralized and reused across endpoints, improving maintainability, security, and readability.

## Two Method (simple and clean)

Simple Method
- In `Infrastructure Module`, open `Extensions/ServiceCollectionExtentions.cs` add services `AddAuthorizationBuilder` method with `AddPolicy` to identify HasNationality
- Open RestaurantsController, and add authorization based on policy we just created at any endpoint we want to test. In
our cases we use `api/restaurants/{id}` endpoint. (Now if we test, any user that have nationality, the user will pass)
- Then we can add more step by create HasNationality equal to any value we want. Eg: Malaysia or Singapore (When test, user 
that only have nationality Malaysia or Singapore only can pass)


Clean Method
- We just add constant in our infrastructure module so that our AddPolicy earlier can just call the constant and not 
hardcode in our files

---

## Step By Step

### Simple Method

In `Infrastructure Module`, open `Extensions/ServiceCollectionExtentions.cs` add services `AddAuthorizationBuilder` method with `AddPolicy` to identify HasNationality

Optional to put Nationality value. Eg: Malaysia or Singapore

#### File: ServiceCollectionExtentions.cs

Add this line of code for restricted it to `Nationality = Malaysia` only

```csharp
services.AddAuthorizationBuilder()
    .AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality","Malaysia"));
```

Open RestaurantsController, and add authorization based on policy we just created at any endpoint we want to test. In
our cases we use `api/restaurants/{id}` endpoint. (Now if we test, any user that have nationality, the user will pass)

---

#### File: RestaurantsController.cs

Add the following code in our `GetById` method

```csharp
[Authorize(Policy = "HasNationality")]
```

Then we can test using our `Restaurants.Api.http` or `Swagger` by login using `testuser2@gmail` or any other user that have `nationality = Malaysia`


---

### Clean Method

This part is to replace our hardcoded value earlier 


Create a new file in `Infrastructure Module` called `Authorization/Constants.cs`

#### File: Constants.cs


```csharp
public static class PolicyNames
{
    public const string HasNationality = "HasNationality";
}

public static class AppClaimTypes
{
    public const string Nationality = "Nationality";
    public const string DateOfBirth = "DateOfBirth";
}
```
#### Why Use Static?

Static is used when a value or functionality belongs to the class itself and does not require an object instance.

Benefits:
- Avoid magic strings – reduces typos by using constants. 
- Compile-time safety – errors are caught during build instead of runtime. 
- Easy refactoring – update the value in one place and it applies everywhere. 
- No instantiation needed – can be accessed directly using the class name. 
- Better performance – no object creation overhead for simple values.

---

#### File: ServiceCollectionExtensions.cs

Then, adjust our ServiceCollectionExtensions.cs earlier from 

```csharp
services.AddAuthorizationBuilder()
    .AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality","Malaysia"));
```
To

```csharp
services.AddAuthorizationBuilder()
            .AddPolicy(PolicyNames.HasNationality, builder => builder.RequireClaim(AppClaimTypes.Nationality));
```

---

#### File: RestaurantsController.cs

Next, we adjust our RestaurantsController.cs from

```csharp
[Authorize(Policy = "HasNationality")]
```

To 

```csharp
[Authorize(Policy = PolicyNames.HasNationality)]
```

Lastly, we need to adjust our `RestaurantsUserClaimsPrincipalFactory` because we hardcoded there also from:

```csharp
public override async Task<ClaimsPrincipal> CreateAsync(User user)
{
    var id = await GenerateClaimsAsync(user);

    if (user.Nationality != null)
    {
        id.AddClaim(new Claim("Nationality", user.Nationality));
    }

    if (user.DateOfBirth != null)
    {
        id.AddClaim(new Claim("DateOfBirth", user.DateOfBirth.Value.ToString("yyyy-MM-dd")));
    }
    
    return new ClaimsPrincipal(id);
}
```

To

```csharp
public override async Task<ClaimsPrincipal> CreateAsync(User user)
    {
        var id = await GenerateClaimsAsync(user);

        if (user.Nationality != null)
        {
            id.AddClaim(new Claim(AppClaimTypes.Nationality, user.Nationality));
        }

        if (user.DateOfBirth != null)
        {
            id.AddClaim(new Claim(AppClaimTypes.DateOfBirth, user.DateOfBirth.Value.ToString("yyyy-MM-dd")));
        }
        
        return new ClaimsPrincipal(id);
    }
```

Then we can test again whether it is working or not

### ⚠️ Important Consideration

Claims stored inside tokens should represent data that does not change frequently.

If a user’s nationality changes, the user must re-authenticate to receive updated claims.






