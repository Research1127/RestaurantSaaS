# Extending User Definition

Previously, our `User` entity relied entirely on the built-in `IdentityUser` properties. 

We are now extending it to add our own property (eg: dateOfBirth, nationality)


## Why Extend IdentityUser?

Extending `IdentityUser` allows us to store additional domain-specific information about users without modifying the ASP.NET Identity framework itself.

This keeps authentication features intact while enabling customization based on business requirements.

## Add Properties in Our User.cs

### File: User.cs

- Open the User.cs and add below property
```csharp
public class User : IdentityUser
{
    public DateOnly? DateOfBirth { get; set; }
    public string? Nationality { get; set; }
}
```
---

## Add Migration File 
- This is to build the new columns for our new properties
- ⚠️ Always review the generated migration file before applying it to ensure no unintended schema changes are included.

```shell
dotnet ef migrations add UserAdditionalPropertiesAdded -s ./Restaurants.Api -p ./Restaurants.Infrastructure
dotnet ef database update -s ./Restaurants.Api -p ./Restaurants.Infrastructure
```

---

## Setup To Update The Table
- Currently, we do not have a way to update the newly created columns, so we need to create a custom endpoint to handle updating user properties.
- So first step is create the controller for the identity called IdentityController.cs

### IdentityController.cs

```csharp
namespace Restaurants.Api.Controllers;

[ApiController]
[Route("api/identity")]

public class IdentityController(IMediator mediator) : ControllerBase
{
    [HttpPatch("user")]
    [Authorize]
    public async Task<IActionResult> UpdateUserDetails(UpdateUserDetailsCommand command)
    {
        await mediator.Send(command);
        return NoContent();
    }
}
```
---

Next, we create a file in `Restaurants.Application/Users/UpdateUserDetailsCommand.cs`

###  UpdateUserDetailsCommand.cs
```csharp
namespace Restaurants.Application.Users;

public class UpdateUserDetailsCommand :  IRequest
{
    public DateOnly? DateOfBirth { get; set; }
    public string? Nationality { get; set; }
}
```

---

Then, we create a file in `Restaurants.Application/Users/UpdateUserDetailsCommandHandler.cs`

###  UpdateUserDetailsCommandHandler.cs
```csharp
namespace Restaurants.Application.Users;

public class UpdateUserDetailsCommandHandler(ILogger<UpdateUserDetailsCommandHandler> logger,
    IUserContext userContext,
    IUserStore<User> userStore) : IRequestHandler<UpdateUserDetailsCommand>
{
    public async Task Handle(UpdateUserDetailsCommand request, CancellationToken cancellationToken)
    {
        var user = userContext.GetCurrentUser();
        logger.LogInformation("Updating user : {UserId}, with {@request}",user!.Id, request);
        var dbUser = await userStore.FindByIdAsync(user!.Id, cancellationToken);

        if (dbUser is null)
        {
            throw new NotFoundException(nameof(User), user!.Id);
        }
        dbUser.Nationality = request.Nationality;
        dbUser.DateOfBirth = request.DateOfBirth;
        
        await userStore.UpdateAsync(dbUser, cancellationToken);
    }
}
```

Explanation of code: `var dbUser = await userStore.FindByIdAsync(user!.Id, cancellationToken);`

✅ What this does:
- Queries the database to find the actual user record.
- Uses the UserId obtained from the authenticated session.

✅ Why it is needed:
- The userContext only gives identity info — not the full database entity.
- You must load the real user before updating it.

✅ About FindByIdAsync:
- Provided by ASP.NET Identity (IUserStore).
- Searches the user table using the primary key.
- Returns the User object if found, otherwise null.

✅ cancellationToken:
- Allows the operation to stop early if the request is cancelled (for example, client disconnect).
- Prevents unnecessary database work.

---
Change the folder of `User` to `Users` so our `IUserStore<User>` is not confuse with our namespace.

Make sure all the namespace that use `User` before changed to `Users`

---

## Change API endpoint location group
Lastly, we open program.cs file to add WithTags code to make sure our all Identity endpoint 
will go to our Identity part 

### Program.cs
```csharp
app.MapGroup("api/identity")
    .WithTags("Identity")
    .MapIdentityApi<User>();
```

## How to test

We run the application, then we login using any user and get the bearer token.

After that, we put the token in button `Authorize` in swagger .

Then, we open our Patch Endpoint that we just create under api/identity/user and patch the data for 
dateOfBirth and nationality

Lastly, check the database whether the data are patched or not





