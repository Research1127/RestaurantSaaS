# CREATING SUBENTITIES

## üçΩÔ∏è Create Dish Endpoint (Nested Resource)
Create a controller called `Restaurants.Api/Controllers/DishesController.cs`

### DishesController.cs
```csharp
[ApiController]
[Route("api/restaurant/{restaurantId}/dishes")] 
// Example api/restaurant/5/dishes

public class DishesController(IMediator mediator) : ControllerBase

{
    [HttpPost]
    public async Task<IActionResult> CreateDish([FromRoute] int restaurantId,
        CreateDishCommand command)
    {
        command.RestaurantId = restaurantId;
        await mediator.Send(command);
        return Created();
    }
}
```
---

### üîç Explanation

`[ApiController]`  
: Enables automatic model validation and better API behavior.

`[Route("api/restaurant/{restaurantId}/dishes")]`  
: Defines a nested route, meaning dishes are always related to a specific restaurant.

**`restaurantId` from route**  
:  Extracted using `[FromRoute]` and assigned to the command before sending.

**`IMediator.Send(command)`**  
:  Sends the request to the application layer using **MediatR**, following Clean Architecture.

**`return Created();`**  
:  Returns **HTTP 201 Created**, indicating the dish was successfully created.

---

Create command file in `Restaurants.Application/Dishes/Commands/CreateDishCreateDishCommand.cs`

### CreateDishCommand.cs
This command represents the request to create a new dish for a specific restaurant.

It is sent from the API controller to the application layer using MediatR which is `IRequest` part.

```csharp
namespace Restaurants.Application.Dishes.Commands.CreateDish;

public class CreateDishCommand : IRequest
{
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
    public decimal Price { get; set; } // Must validate
    public int? KiloCalories { get; set; } // Must validate
    public int RestaurantId { get; set; }
}
```
Note that `Price` and `KiloCalories` must be validate so we create the validator file called `Restaurants.Application/Dishes/Commands/CreateDishCommandValidator.cs` that use FluentValidation.

---
### CreateDishCommandValidator.cs

```csharp
public class CreateDishCommandValidator : AbstractValidator<CreateDishCommand>
{
    // Validate Price and Kilocalories
    public CreateDishCommandValidator()
    {
        RuleFor(dish => dish.Price )
            .GreaterThanOrEqualTo(0)
            .WithMessage("Price must be non negative number");
        RuleFor(dish => dish.KiloCalories )
            .GreaterThanOrEqualTo(0)
            .WithMessage("KiloCalories must be non negative number");
    }
}
```

### üîç Explanation
`AbstractValidator<CreateDishCommand>`
: Defines validation rules specifically for the CreateDishCommand object.

RuleFor(dish => dish.Price)
: Ensures the dish price is not negative, preventing invalid pricing data.

RuleFor(dish => dish.KiloCalories)
: Ensures calorie value is not negative when provided.

WithMessage(...)
: Custom error messages returned to the API client when validation fails.

---

Then we create `Restaurants.Application/Dishes/Commands/CreateDishCommandHandler.cs`

### CreateDishCommandHandler.cs

This command handler processes the CreateDishCommand request.

It validates that the parent restaurant exists, maps the command to a Dish entity, and saves it to the database using repository interfaces.

```csharp
namespace Restaurants.Application.Dishes.Commands.CreateDish;

public class CreateDishCommandHandler(ILogger<CreateDishCommandHandler> logger,
    IRestaurantsRepository restaurantsRepository,
    IDishesRepository dishesRepository, IMapper mapper) : IRequestHandler<CreateDishCommand>
{
    public async Task Handle(CreateDishCommand request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Creating new dish {@DishRequest}", request);
        var restaurant = await restaurantsRepository.GetByIdAsync(request.RestaurantId);
        if (restaurant == null) throw new NotFoundException(nameof(Restaurant), 
            request.RestaurantId.ToString());
        
        var dish = mapper.Map<Dish>(request); // Setup in DishesProfile.cs
        await dishesRepository.Create(dish); // Create IDishesRepository.cs and DishesRepository.cs
    }
}
```

### üîç Explanation
IRequestHandler<CreateDishCommand>
: Marks this class as the handler for CreateDishCommand.
: It contains the business logic for processing the creation of a new dish.

ILogger<CreateDishCommandHandler>
: Logs the incoming request for debugging and monitoring purposes.

IRestaurantsRepository.GetByIdAsync
: Ensures the restaurant exists before creating a dish.
: If not found, it throws a NotFoundException.

IMapper.Map<Dish>(request)
: Uses AutoMapper to convert the command DTO (CreateDishCommand) into a domain entity (Dish).
: Mapping rules are defined in DishesProfile.cs.

IDishesRepository.Create(dish)
: Persists the new dish into the database using repository abstraction.

---

Next, we create `Restaurants.Domain/Repositories/IDishesRepository.cs`

### IDishesRepository.cs 
This is a repository interface for the Dish entity.


```csharp
namespace Restaurants.Domain.Repositories;

public interface IDishesRepository
{
    Task<int> Create(Dish entity);
    
}
```

### üîç Explanation

Task<int> Create(Dish entity)
: Responsible for creating a new dish in the database.
: Returns the ID of the newly created dish asynchronously.
: Uses async/await pattern to support non-blocking database operations.

---

Next, we create `Restaurants.Infrastructure/Repositories/DishesRepository.cs` in Infrastructure layer

### DishesRepository.cs 

This class is the concrete implementation of IDishesRepository that interacts with the database using Entity Framework Core.
It provides the actual data access logic for the Dish entity.

```csharp
namespace Restaurants.Infrastructure.Repositories;

internal class DishesRepository(RestaurantsDbContext dbContext) : IDishesRepository
{
    public async Task<int> Create(Dish entity)
    {
        dbContext.Dishes.Add(entity);
        await dbContext.SaveChangesAsync();
        return entity.Id;
    }
}
```

### üîç Explanation
internal class DishesRepository
: Concrete repository in the infrastructure layer, implementing IDishesRepository.
: Handles database operations for Dish entities.

RestaurantsDbContext dbContext
: Injected EF Core DbContext for accessing database tables.
: Provides DbSet<Dish> for CRUD operations.

dbContext.Dishes.Add(entity)
: Adds the new dish entity to the EF Core change tracker.

await dbContext.SaveChangesAsync()
: Saves the changes asynchronously to the database.

return entity.Id
: Returns the generated Dish ID after it is inserted into the database.

---

Then, we need to edit `Restaurants.Application/Dishes/Dtos/DishesProfile.cs` and add `CreateMap<CreateDishCommand, Dish>();`

### DishesProfile.cs

This profile defines mappings between DTOs, commands, and domain entities. AutoMapper automatically handles object-to-object mapping based on these rules.

```csharp
namespace Restaurants.Application.Dishes.Dtos;

public class DishesProfile : Profile
{
    public DishesProfile()
    {
        CreateMap<Dish, DishDto>();
        CreateMap<CreateDishCommand, Dish>();
    }
}
```

### üîç Explanation
CreateMap<CreateDishCommand, Dish>()
: Maps the CreateDishCommand object (from API input) to a Dish entity (for database).
: Automatically copies properties with the same name, like Name, Description, Price, KiloCalories, RestaurantId.
: Simplifies handler code so you don‚Äôt manually assign each property.

---

Next, in Infrastructure Layer, we edit `Restaurants.Infrastructure/Extensions/ServiceCollectionExtensions.cs` and add this line:

```csharp
services.AddScoped<IDishesRepository, DishesRepository>();
```

This is to register our repository earlier

---

Lastly, run our application and test it in Swagger, make sure to put wrong RestaurantId also so that we know the error handling are correct or not










