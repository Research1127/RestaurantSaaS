# RETRIEVING SUBENTITIES
### Need to read the explanation for a better understanding

## Part 1 - Get All Dishes for specific Restaurant Id
Edit the DishesController.cs

### DishesController.cs
- Add the HttpGet method (must see the video again)
- Use `ActionResult` for the task to return the collection of `DishDto` values 
(we use `ActionResult` instead of `IActionResult` because we want to return the JSON and 
status response body instead of returning the status respond only)
- Create var dishes and use mediator to send a new request `GetDishesForRestaurantQuery`

```csharp
   [HttpGet]
    public async Task<ActionResult<IEnumerable<DishDto>>> GetAllForRestaurant([FromRoute] int restaurantId)
    {
        var dishes = await mediator.Send(new GetDishesForRestaurantQuery(restaurantId));
        return Ok(dishes);
    }
```
---
Create file `Restaurant.Application/Dishes/Queries/GetDishesForRestaurant/GetDishesForRestaurantQuery.cs`


### GetDishesForRestaurantQuery.cs
#### Note that this part will get all dishes for a Restaurants
- Implement `IRequest` interface and for return type we must specify we would like to return 
the collection of `DishDto` object
- Also here we need to create restaurant Id property and initialize it in our primary constructor
```csharp
namespace Restaurants.Application.Dishes.Queries.GetDishesForRestaurant;

public class GetDishesForRestaurantQuery(int restaurantId) : IRequest<IEnumerable<DishDto>>
{
    public int  RestaurantId { get; } = restaurantId;
}
```
---

Create file `Restaurant.Application/Dishes/Queries/GetDishesForRestaurantQueryHandler.cs`

### GetDishesForRestaurantQueryHandler.cs
- Implement `IRequestHandler` interface that point out to our query file
- And the return type is `IEnumerable<DishDto>`
- Inject `ILogger` interface
- Inject `IRestaurantsRepository` to check whether the restaurant exist or not
- Create var `restaurant` and use `GetByIdAsync` method
- Check if **null** or not and if null throw the `NotFoundException`
- Create var `results` and use mapper to map the collection `IEnumerable` for `DishDto` from our `restaurant.dishes`
(`RestaurantRepository` already include the dishes in `GetByIdAsync`, so we just use it)
- Lastly, we return the `results`

```csharp
namespace Restaurants.Application.Dishes.Queries.GetDishesForRestaurant;

public class GetDishesForRestaurantQueryHandler(ILogger<GetDishesForRestaurantQueryHandler> logger,
    IRestaurantsRepository restaurantsRepository,
    IMapper mapper) : IRequestHandler<GetDishesForRestaurantQuery, IEnumerable<DishDto>>
{
    public async Task<IEnumerable<DishDto>> Handle(GetDishesForRestaurantQuery request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Retrieving dishes from restaurant id: {RestaurantId}" ,request.RestaurantId);
        var restaurant = await restaurantsRepository.GetByIdAsync(request.RestaurantId);
        if (restaurant == null) throw new NotFoundException(nameof(Restaurant), 
            request.RestaurantId.ToString());
        
        var results = mapper.Map<IEnumerable<DishDto>>(restaurant.Dishes);
        return results;
       
    }
}
```
---

## Part 2: Get Single Dish for Specific Restaurant Id

Edit the `DishesController.cs`
- Copy and paste the `HttpGet` method for retrieving all dishes earlier
- Remove the `IEnumerable` because we dont want to retrieve the collection of dishes and add 
1 more parameter FromRoute int `dishId`
- Create var `dish` and use mediator to send a new request GetDishByIdForRestaurantQuery
- Past 1 more extra parameter which is int `dishId` using FromRoute method

```csharp
  [HttpGet("{dishId}")]
    public async Task<ActionResult<DishDto>> GetByIdForRestaurant([FromRoute] int restaurantId, [FromRoute]int dishId)
    {
        var dish = await mediator.Send(new GetDishByIdForRestaurantQuery(restaurantId,dishId));
        return Ok(dish);
    }
```
---

Create file `Restaurant.Application/Dishes/Queries/GetDishByIdForRestaurant/GetDishByIdForRestaurantQuery.cs`

### GetDishByIdForRestaurantQuery.cs
- In primary constructor pass int `restaurantId` and int `dishId`
- Implement `IRequest` interface for a single `DishDto` value
- Create the properties of `RestauranId` and `DishId` that will initialize the value from our primary constructor

```csharp
namespace Restaurants.Application.Dishes.Queries.GetDishByIdForRestaurant;

public class GetDishByIdForRestaurantQuery(int restaurantId, int dishId) : IRequest<DishDto>
{
    public int RestaurantId { get; } = restaurantId;
    public int DishId { get; } = dishId;
}
```
---

Create file `Restaurant.Application/Dishes/Queries/GetDishByIdForRestaurant/GetDishByIdForRestaurantQueryHandler.cs`

### GetDishByIdForRestaurantQueryHandler.cs
- Implement the `IRequestHandler` for our `GetDishByIdForRestaurantQuery` and return type of `DishDto`
- Add `ILogger` to log the information
- Add `Imapper` to map our `DishDto`
- Create var `restaurant` using `IRestaurantRepository` **(GetByIdAsync)** method
- Check if `restaurant` null, throw the `NotFoundException`
- Create var `dish` using **restaurant.Dishes** and use `FirstOrDefault` method to find the first dishId
- If got **null** then throw the `NotFoundException`
- Create var `result` and using mapper to map to dishDto from our dish entity
- Return the `result`

```csharp
namespace Restaurants.Application.Dishes.Queries.GetDishByIdForRestaurant;

public class GetDishByIdForRestaurantQueryHandler(ILogger<GetDishByIdForRestaurantQueryHandler> logger,
    IRestaurantsRepository restaurantsRepository,
    IMapper mapper) : IRequestHandler<GetDishByIdForRestaurantQuery, DishDto>
{
    public async Task<DishDto> Handle(GetDishByIdForRestaurantQuery request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Get the dish: {dishId} from restaurant: {restaurantId}",request.DishId,request.RestaurantId);
        var restaurant = await restaurantsRepository.GetByIdAsync(request.RestaurantId);
        if (restaurant == null) 
            throw new NotFoundException(nameof(Restaurant), request.RestaurantId.ToString());
        
        var dish = restaurant.Dishes.FirstOrDefault(d => d.Id == request.DishId);
        if (dish == null) throw new NotFoundException(nameof(Dish), request.DishId.ToString());
        
        var result = mapper.Map<DishDto>(dish);
        return result;

    }
}
```



