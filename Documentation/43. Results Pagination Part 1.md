# Result Pagination Part 1

Overview:
This guide explains how to implement results pagination for restaurants in the application. Pagination allows fetching
a subset of data from a large dataset, improving performance and user experience.

## Query Definition

### File: GetALlRestaurantsQuery.cs

This query defines the parameters for retrieving restaurants, including optional search phrases and pagination settings.

```csharp
public class GetAllRestaurantsQuery : IRequest<IEnumerable<RestaurantDto?>>
{
    public string? SearchPhrase { get; set; }       // Optional filter for restaurant name or description
    public int PageNumber { get; set; }  
    public int PageSize { get; set; } 
}
```

---

## Query Handler

### File: GetALlRestaurantsQueryHandler.cs

The handler processes the query and retrieves the paginated data from the repository.

```csharp
    public async Task<IEnumerable<RestaurantDto>> Handle(GetAllRestaurantsQuery request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Getting all restaurants");
        
        // Add PageNumber and PageSize
        var restaurants = await restaurantRepository.GetAllMatchingAsync(request.SearchPhrase,
            request.PageSize, 
            request.PageNumber);
        var restaurantsDtos = mapper.Map<IEnumerable<RestaurantDto>>(restaurants);

        
        return restaurantsDtos!;
    }
```
---

## Repository Contract

### File: IRestaurantsRepository.cs

Add the pagination parameters to the repository interface:

```csharp
Task<IEnumerable<Restaurant>> GetAllMatchingAsync(string? searchPhrase, int pageSize, int pageNumber);
```

---

## Repository Implementation

### File: RestaurantsRepository.cs

Implement the repository method to apply filtering and pagination using Skip and Take.

```csharp
Business Logic
// PageSize = 5, PageNumber = 3 
// Skip => PageSize * (PageNumber - 1) => 5 * (3-1) = 10
```

Update the GetAllMatchingAsync implementation

```csharp
public async Task<IEnumerable<Restaurant>> GetAllMatchingAsync(string? searchPhrase,  int pageSize, int pageNumber)
{
    var searchPhraseLower = searchPhrase?.ToLower();
    
    // PageSize = 5, PageNumber = 3 : Skip => PageSize * (PageNumber - 1) => 5 * (3-1)
    var restaurants = await dbContext.Restaurants
        .Where(r => searchPhraseLower == null || (r.Name.ToLower().Contains(searchPhraseLower) 
                                                  || r.Description.ToLower().Contains(searchPhraseLower)))
        .Skip(pageSize * (pageNumber - 1))
        .Take(pageSize)
        .ToListAsync();
    
    return restaurants;
}
```

Explanation:
- Example: PageSize = 5, PageNumber = 3
- Skip = PageSize * (PageNumber - 1) → 5 * (3 - 1) = 10
- This will skip the first 10 records and return the next 5 records.

---

## How To Test

You can test the paginated endpoint using an HTTP client like Postman or cURL:

```yaml
GET {{Restaurants_Api_HostAddress}}/api/restaurants?pageNumber=2&pageSize=5
Authorization: Bearer {{token}}
Accept: application/json
```

- pageNumber: The page you want to retrieve (1-based index).
- pageSize: Number of restaurants per page.
- serchPhrase (optional): Filter restaurants by name or description.

---

✅ Benefits of Pagination:
1. Reduces memory usage on the server. 
2. Improves API response time. 
3. Enhances frontend experience by loading data incrementally. 
4. Supports filtering with optional search phrases.
