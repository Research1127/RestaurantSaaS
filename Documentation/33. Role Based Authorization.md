# Role Based Authorization

Role-based authorization is implemented to restrict access to specific endpoints based on a user’s assigned role, 
ensuring controlled access to sensitive operations.

## Create The Constants Role

Create a file in `Restaurants.Domain/Constants/UserRoles.cs`

### File: UserRoles.cs

```csharp
public static class UserRoles
{
    public const string Admin = "Admin";
    public const string User = "User";
    public const string Owner = "Owner";
}
```
---


## Seeding UserRoles in RestaurantSeeder

This approach improves deployment consistency by ensuring required roles are always available across different environments without manual configuration.


### File: RestaurantsSeeder.cs
Open RestaurantsSeeder.cs and add below code:
```csharp
public async Task Seed()
    {
        if (await dbContext.Database.CanConnectAsync())
        {
            if (!dbContext.Restaurants.Any())
            {
                var restaurants = GetRestaurants();
                dbContext.Restaurants.AddRange(restaurants);
                await dbContext.SaveChangesAsync();
            }
            
            // Part 1
            if (!dbContext.Roles.Any())
            {
                var roles = GetRoles();
                dbContext.Roles.AddRange(roles);
                await dbContext.SaveChangesAsync();
            }
        }  
        
    }
    // Part 2
    private IEnumerable<IdentityRole> GetRoles()
    {
        List<IdentityRole> roles =
        [
            new(UserRoles.User),
            new(UserRoles.Owner),
            new(UserRoles.Admin),
        ];
        return roles;
    }

```
`Part 1`

This logic checks whether any roles exist in the database. If no roles are found, the system retrieves a predefined list 
of roles and inserts them into the database. This ensures that essential roles are available for authentication and 
authorization without requiring manual database setup.

`Part 2`

The `GetRoles()` method defines and returns a collection of predefined Identity roles (User, Owner, Admin). These roles 
represent the application’s authorization levels and are used during the seeding process to populate the database with 
default role entries.

After running the application, the system automatically creates the roles if they do not already exist. 
The `AspNetRoles` table should now contain the three newly created roles.


---

## Create The User Using Swagger

Create 3 user account using Swagger (api endpoint)
Created account:
- admin@gmail.com
- user@gmail.com
- owner@gmail.com

All password = Password1!

Now we can check the `AspNetUsers` table in our database have 3 new user's account

---

## Assigning Roles to Each User

We have one more table called `AspNetUserRoles` that acts as a mapping table that links users `(AspNetUsers)` to their assigned roles `(AspNetRoles)`

Retrieve the corresponding `UserId` and `RoleId` values from the `AspNetUsers` and `AspNetRoles` tables before executing the 
insert query to ensure accurate role assignments.

Inser Query:

```postgresql
insert into public."AspNetUserRoles" ("UserId", "RoleId")
values ('2825d4b9-b737-432c-ba6b-cc5859a084dd','4fb155c6-72e5-4e8a-9047-8dd8ca11b264'),
       ('8fd8fc97-c244-4b2a-b788-21775b2cce6b','ecd00bf0-2768-4ec2-99f9-20226bfb28ef'),
       ('5f098f96-d660-4881-99c1-7dbe5d706a11','f7742bf6-a29f-4de6-a237-99d18b6e9820');
```

**Notes:**

For production environments, roles are typically assigned using UserManager to ensure compatibility with ASP.NET Identity workflows.

So, we no need to manually insert it into `AspNetUserRoles` and just use below function:

```csharp
 UserManager.AddToRoleAsync()
```
Why?

✅ respects Identity validation

✅ avoids broken relationships

✅ safer during migrations

✅ less database risk

---

## Register our IdentityRole

Register our IdentityRole in `ServiceCollectionExtensions.cs` of our `Infrastructure module`
Add AddRoles method

### File: ServiceCollectionExtensions.cs

```csharp
services.AddIdentityApiEndpoints<User>()
            .AddRoles<IdentityRole>()
            .AddEntityFrameworkStores<RestaurantsDbContext>();
```

---

## Adjust Our Controller To Authorize Based on Roles

Test using `POST` method to `createrestaurant` by giving owner roles
- This ensures that only users assigned the `Owner` role are authorized to create new restaurants.

### File: RestaurantsController.cs
Add `[Authorize(Roles = UserRoles.Owner)]`

```csharp
[HttpPost]
    [Authorize(Roles = UserRoles.Owner)]
    public async Task<IActionResult> CreateRestaurant(CreateRestaurantCommand command)
    {
        int id = await mediator.Send(command);
        return CreatedAtAction(nameof(GetById), new { id }, null);
    }
```

---
## How to test

We run the application, then we login using `user = owner` and get the bearer token.

After that, we put the token in button `Authorize` in swagger .

Then, we open our `POST` Endpoint for `api/restaurants` and create a new restaurant

Result:
```json
Status Code: 201
Response headers
 content-length: 0 
 date: Sun,01 Feb 2026 16:22:17 GMT 
 location: http://localhost:5204/api/restaurants/8 
 server: Kestrel
```

But,if we use other users instead of `owner`. The result will be:
```json
Status Code: 403
Error: Forbidden
```

**Note:** This restriction applies only to the endpoint decorated with [Authorize(Roles = UserRoles.Owner)].


