# User Resources

`User Resources` focuses on strengthening the restaurant management system by introducing resource ownership. 
The objective is to ensure that only authorized users can modify resources they own, thereby improving application security.

## Why Ownership Tracking Is Important

Previously, the system allowed users with the Owner role to create restaurants, but any authenticated user could update or delete restaurant records. This created a security risk because sensitive data could be modified by unauthorized users.

Ownership tracking solves this problem by enforcing resource-based authorization, ensuring that only the creator (owner) of a restaurant can manage it.

## Update Models

### File: Restaurant.cs

Add owner properties to track who created each restaurant:

```csharp
public User Owner { get; set; } = default!;
public string OwnerId { get; set; } = default!;
```

### File: User.cs

Track restaurants owned by a user:

```csharp
public List<Restaurant>? OwnedRestaurants { get; set; } = [];
```

---

## Configure Entity Relationships

In the `Infrastructure Module`, update `RestaurantsDbContext.cs`:

### File: RestaurantsDbContext.cs

```csharp
modelBuilder.Entity<User>()
            .HasMany(o => o.OwnedRestaurants)
            .WithOne(r => r.Owner)
            .HasForeignKey(r => r.OwnerId);
```
This establishes a one-to-many relationship between User and Restaurant:
- A User can own multiple restaurants.
- Each Restaurant has exactly one owner.

---

## Create Migration File

Add a migration to update the database schema:


```shell
dotnet ef migrations add RestaurantOwnerAdded -s ./Restaurants.Api -p ./Restaurants.Infrastructure
```

---

## Edit The Migration File

Update the migration to add the `OwnerId` column and set default values:

```csharp
protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "OwnerId",
                table: "Restaurants",
                type: "text",
                nullable: false,
                defaultValue: "");
            
            // Edit Here but make sure this is Postgres. If other database the query is different
            migrationBuilder.Sql(@"UPDATE ""Restaurants"" SET ""OwnerId"" = (SELECT ""Id"" FROM ""AspNetUsers"" LIMIT 1);");

            migrationBuilder.CreateIndex(
                name: "IX_Restaurants_OwnerId",
                table: "Restaurants",
                column: "OwnerId");

```

⚠️ Note: If using a different database, the SQL update query may differ.

---

## Update CreateRestaurantCommandHandler file

Ensure new restaurants are automatically assigned to the current user:

```csharp
public class CreateRestaurantCommandHandler(ILogger<CreateRestaurantCommandHandler> logger,
    IMapper mapper,IRestaurantsRepository restaurantRepository,
    IUserContext userContext) : IRequestHandler<CreateRestaurantCommand, int>
{
    public async Task<int> Handle(CreateRestaurantCommand request, CancellationToken cancellationToken)
    {
        var currentuser = userContext.GetCurrentUser();
        
        
        logger.LogInformation("{UserEmail} [{UserId}] is creating a new restaurant {@Restaurant}",
            currentuser.Email,
            currentuser.Id,
            request);
        var restaurant = mapper.Map<Restaurant>(request);
        
        restaurant.OwnerId = currentuser.Id;
        
        int id = await restaurantRepository.Create(restaurant);
        return id;
    }
}
```
---

## How To Test

- Run the application. 
- Login with `owner@gmail.com` (must have the Owner role). 
- Create a new restaurant through the `CreateRestaurant` endpoint. 
- Verify in the database that the `OwnerId` is automatically set to the current user’s ID. 
- Other users without the Owner role are forbidden from creating restaurants due to [Authorize(Roles = UserRoles.Owner)].

