# Add Total Pages, Total Count, Range Displayed Result

## Overview

When building APIs that return large datasets, returning only the data is not enough.
The frontend also needs metadata to properly render pagination controls.

This implementation adds:

‚úÖ Total number of items

‚úÖ Total number of pages

‚úÖ Current item range (e.g., showing 11‚Äì20 of 5009)

‚úÖ Paginated dataset

This approach follows enterprise API design practices and improves scalability and user experience.

---

## Create PagedResult Class

Create a new class in Application Module called Common/PagedResult.cs

### PagedResult.cs

```csharp
namespace Restaurants.Application.Common;

public class PagedResult<T>
{
    public PagedResult(List<T> items,int totalCount,int pageSize, int pageNumber)
    {
        Items = items;
        TotalItemsCount = totalCount;
        TotalPages = (int)Math.Ceiling(totalCount /(double) pageSize);
        ItemsFrom =  pageSize *  (pageNumber - 1) + 1;
        ItemsTo = ItemsFrom + pageSize - 1; 
        
    }
    public List<T> Items { get; set; }
    public int TotalPages { get; set; }
    public int TotalItemsCount { get; set; }
    public int ItemsFrom { get; set; }
    public int ItemsTo { get; set; }
}
```

---

‚úÖ Why This Matters

Without metadata:

```yaml
Frontend has NO idea:
- How many pages exist
- When to disable "Next"
- What range is displayed
```

With PagedResult:
```yaml
Showing 11‚Äì20 of 5009 restaurants
```
This is how professional APIs behave.

---

## Update the Query

### File: GetAllRestaurantsQuery.cs

Change the return type from:
```csharp
IRequest<IEnumerable<RestaurantDto>>
```
to:

```csharp
IRequest<PagedResult<RestaurantDto>>
```
Updated Code

```csharp
// Change IRequest<IEnumerable<RestaurantDto>> to IRequest<PagedResult<RestaurantDto>>
public class GetAllRestaurantsQuery : IRequest<PagedResult<RestaurantDto>>
{
    // I set default 1 and 10 to prevent error get all restauran return no item
    public string? SearchPhrase {get; set;}
    public int PageNumber {get; set;} = 1;
    public int  PageSize {get; set;} = 10;
}
```

Why?

Because the API is no longer returning just data ‚Äî it returns structured pagination information.

---


## Update Query Handler

### File: GetAllRestaurantsQueryHandler.cs

The handler now constructs the PagedResult.

```csharp
namespace Restaurants.Application.Restaurants.Queries.GetAllRestaurants;

// Change the IEnumerable to PagedResult
public class GetAllRestaurantsQueryHandler(ILogger<GetAllRestaurantsQueryHandler> logger,
    IMapper mapper,
    IRestaurantsRepository restaurantRepository) : IRequestHandler<GetAllRestaurantsQuery, PagedResult<RestaurantDto>>
{
    public async Task<PagedResult<RestaurantDto>> Handle(GetAllRestaurantsQuery request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Getting all restaurants");
        
        var (restaurants, totalCount) = await restaurantRepository.GetAllMatchingAsync(request.SearchPhrase,
            request.PageSize, 
            request.PageNumber);
        var restaurantsDtos = mapper.Map<IEnumerable<RestaurantDto>>(restaurants);
        
        // Add here
        var result = new PagedResult<RestaurantDto>(restaurantsDtos, totalCount,request.PageSize,request.PageNumber);

        // Change to return result
        return result;
    }
}

```

üî• Important Design Decision

Notice the repository returns:

```csharp
(IEnumerable<Restaurant>, int totalCount)
```
‚ùå Counting AFTER pagination

‚ùå Running different filters for count vs data

Both queries use the same base query.

---


## Update Repository Interface
### File: IRestaurantsRepository.cs

```csharp
  // Adjust here also
    Task<(IEnumerable<Restaurant>,int)> GetAllMatchingAsync(string? searchPhrase, int pageSize, int pageNumber);
```

Returning a tuple keeps the method simple while providing both required values.

---

## Update Repository Implementation
### File: RestaurantsRepository.cs

```csharp
// Change Task<IEnumerable<Restaurant>> to Task<(IEnumerable<Restaurant>,int)>
    public async Task<(IEnumerable<Restaurant>,int)> GetAllMatchingAsync(string? searchPhrase, int pageSize, int pageNumber)
    {
        var searchPhraseLower = searchPhrase?.ToLower();
        
        // Build the base query FIRST
        var baseQuery = dbContext.Restaurants
            .Where(r => searchPhraseLower == null || (r.Name.ToLower().Contains(searchPhraseLower)
                                                      || r.Description.ToLower().Contains(searchPhraseLower)));
        // Count BEFORE pagination
        var totalCount = await baseQuery.CountAsync();
        
        var restaurants = await baseQuery
            .Skip(pageSize * (pageNumber - 1))
            .Take(pageSize)
            .ToListAsync();
        
        return (restaurants,totalCount); // add tuple here
    }
```

‚úÖ Why Build baseQuery First?

This ensures:

‚úî Count matches filtered data

‚úî No pagination errors

‚úî No incorrect page numbers


---

## How to Test

Use this endpoint to test:
```yaml
### Get restaurant based on filtering
GET {{Restaurants_Api_HostAddress}}/api/restaurants?searchPhrase=group&pageSize=10&pageNumber=1
//Authorization: Bearer {{token}}
Accept: application/json
```

Example Response:
```yaml
"totalPages": 104,
"totalItemsCount": 1034,
"itemsFrom": 1,
"itemsTo": 10
```