# Resource Based Authorization

Resource-Based Authorization focuses on securing the restaurant management system by controlling access to resources based on ownership.

The objective is to ensure that only users with proper permissions—such as the restaurant owner or an admin—can perform
actions like update or delete, thereby improving application security and consistency.

---

## Create Resource Operation Enum

Create an enum inside the Infrastructure Module:

File: Authorization/ResourceOperation.cs

Create an enum file in Infrastructure Module, under Authorization/ResourceOperation.cs
```csharp
namespace Restaurants.Infrastructure.Authorization;

public enum ResourceOperation
{
    Create,
    Read,
    Update,
    Delete
            
}
```
This enum standardizes authorization operations across the application and prevents the use of magic strings.

---

## Implement Authorization Service

Create the authorization service responsible for validating whether a user can perform an operation on a restaurant resource.

### File: Authorization/Services/RestaurantAuthorizationService.cs

```csharp
namespace Restaurants.Infrastructure.Authorization.Services;

public class RestaurantAuthorizationService(
    ILogger<RestaurantAuthorizationService> logger,
    IUserContext userContext) : IRestaurantAuthorizationService
{
    public bool Authorize(Restaurant restaurant, ResourceOperation resourceOperation)
    {
        var user = userContext.GetCurrentUser();

        logger.LogInformation(
            "Authorizing user {UserEmail} to perform {Operation} on restaurant {RestaurantName}",
            user.Email,
            resourceOperation,
            restaurant.Name);

        // Anyone can read or create
        if (resourceOperation == ResourceOperation.Read || resourceOperation == ResourceOperation.Create)
        {
            logger.LogInformation("Create/Read operation - authorization successful");
            return true;
        }

        // Only admins can delete any restaurant
        if (resourceOperation == ResourceOperation.Delete && user.IsInRole(UserRoles.Admin))
        {
            logger.LogInformation("Admin delete operation - authorization successful");
            return true;
        }

        // Owners can update or delete their own restaurants
        if ((resourceOperation == ResourceOperation.Delete || resourceOperation == ResourceOperation.Update)
            && user.Id == restaurant.OwnerId)
        {
            logger.LogInformation("Owner operation - authorization successful");
            return true;
        }

        return false;
    }
}
```

---

## Create Authorization Interface

Extract the interface to allow registration in the Dependency Injection container.

### File: IRestaurantAuthorizationService.cs

```csharp
namespace Restaurants.Infrastructure.Authorization.Services;

public interface IRestaurantAuthorizationService
{
    bool Authorize(Restaurant restaurant, ResourceOperation resourceOperation);
}
```

---

Register Service in Dependency Injection

## Register Service in Dependency Injection

Update ServiceCollectionExtensions.cs

### File: ServiceCollectionExtensions.cs

```csharp
services.AddScoped<IRestaurantAuthorizationService, RestaurantAuthorizationService>();
```

---

## Maintain Clean Architecture Boundaries

So, next part is we need to inject our newly created `RestaurantAuthorizationService.cs` in our DeleteHandler and other related handler

But, we cannot inject directly as our Application doesn't reference to our infrastructure layer and just reference to domain

So, this case similar to repository part which is repository in infrastructure need to have interface in Domain layer so application layer can use

Now, we create an interfaces folder in our `Domain Layer` called `Interfaces`

After that we move our `IRestaurantAuthorizationService.cs` file into that folder

Adjust the namespace for `IRestaurantAuthorizationService.cs`

Then we need to move our `ResourceOperation.cs` file also into our `Constants` folder in `Domain Layer`

---

## Inject Authorization Service into Command Handlers

Now inject the authorization service into handlers that modify resources.

Now we go to `DeleteRestaurantCommandHandler.cs` file to inject our `RestaurantAuthorizationService`

### File: DeleteRestaurantCommandHandler.cs

```csharp
public class DeleteRestaurantCommandHandler(ILogger<DeleteRestaurantCommandHandler> logger,
    IRestaurantsRepository restaurantsRepository,
    IRestaurantAuthorizationService restaurantAuthorizationService) : IRequestHandler<DeleteRestaurantCommand>
{
    public async Task Handle(DeleteRestaurantCommand request, CancellationToken cancellationToken)
    {
        logger.LogInformation($"Deleting restaurant with id : {request.Id}");
        var restaurant = await restaurantsRepository.GetByIdAsync(request.Id);
        if (restaurant is null)
            throw new NotFoundException(nameof(Restaurant), request.Id.ToString());

        if (!restaurantAuthorizationService.Authorize(restaurant, ResourceOperation.Delete))
        {
            throw new ForbidException();
        }
        
        await restaurantsRepository.Delete(restaurant);

    }
}
```

---


## Create Forbidden Exception

Create a custom exception to represent unauthorized access.

Create `ForbidException()` in Domain Module under Exceptions folder

File: Restaurants.Domain/Exceptions/ForbidException.cs

```csharp
namespace Restaurants.Domain.Exceptions;

public class ForbidException : Exception
{
    
}
```

---

## Apply Authorization Across Handlers

Copy similar code in DeleteRestaurantCommandHandler.cs and paste it in the following handler files:

- UpdateRestaurantCommandHandler.cs
- DeleteDishesForRestaurantCommandHandler.cs
- CreateDishCommandHandler.cs

Example:
```csharp
if (!restaurantAuthorizationService.Authorize(restaurant, ResourceOperation.Update))
        {
            throw new ForbidException();
        }
```

✅ Make sure to change `ResourceOperation.Update` to Delete, Update or Create based on the files

✅ Make sure to inject the Restaurant Authorization Service

---

## Configure Error Handling Middleware

Update your global exception middleware to handle `ForbidException`.

```csharp
catch (ForbidException)
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Access Forbidden");
        }
```

This ensures the API returns a proper `403` Forbidden response when authorization fails.

---

## How to test
	1.	Run the application.
	2.	Attempt to modify or delete a restaurant:

Expected Results:

✅ Owner can update/delete their restaurant
✅ Admin can delete any restaurant but `cannot update other restaurant`
❌ Unauthorized users receive 403 Forbidden

---

## Suggestion:

✅ If requirement need admin to have full access then make sure `IsInRole = Admin` return true in RestaurantAuthorizationService.cs

```csharp
// Admin has full access
if (user.IsInRole(UserRoles.Admin))
{
    return true;
}
```




