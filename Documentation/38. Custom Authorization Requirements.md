# Custom Authorization Requirement

Custom authorization is used to enforce specific access rules that cannot be handled by basic role-based authorization. It ensures that only users who meet certain conditions can access protected resources.

## Purpose

The main purpose of custom authorization is to improve application security by validating user permissions based on business logic such as resource ownership, subscription status, or department access.

## Creating a Policy Name

Within the `Infrastructure module`, define policy names inside `Authorization/Constants.cs`.

### File: Constants.cs

```csharp
public static class PolicyNames
{
    public const string HasNationality = "HasNationality";
    public const string AtLeast20 = "AtLeast20";
}

```

These constants prevent hardcoding policy strings throughout the application and improve maintainability.

---

## Creating a Custom Requirement

Next, create a requirement that defines the rule users must satisfy.

In Infrastructure Module, we create a new requirement file Authorization/Requirements/MinimumAgeRequirement.cs

### File: MinimumAgeRequirement.cs

```csharp
public class MinimumAgeRequirement(int minimumAge) : IAuthorizationRequirement
{
    public int MinimumAge { get; } = minimumAge;
}
```

This requirement specifies that a user must meet a minimum age before accessing certain endpoints.

---

## Implementing the Authorization Handler

In same folder, create MinimumAgeRequirementHandler.cs

### File: MinimumAgeRequirementHandler.cs

```csharp
namespace Restaurants.Infrastructure.Authorization.Requirements;

public class MinimumAgeRequirementHandler(ILogger<MinimumAgeRequirementHandler> logger,
    IUserContext userContext) : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
    {
        var currentUser = userContext.GetCurrentUser();
        logger.LogInformation("User: {Email}, date of birth {DoB} - Handling MinimumAgeRequirement",
            currentUser.Email,
            currentUser.DateOfBirth);

        if (currentUser.DateOfBirth == null)
        {
            logger.LogWarning("User date of birth null");
            context.Fail();
            return Task.CompletedTask;
        }

        if (currentUser.DateOfBirth.Value.AddYears(requirement.MinimumAge) <= DateOnly.FromDateTime(DateTime.Today))
        {
            logger.LogInformation("Authorization Succeeded");
            context.Succeed(requirement);
        }
        else
        {
            context.Fail();
        }
        
        return Task.CompletedTask;
    }
}
```

The handler retrieves the current user, evaluates their age, and either approves or denies access.

---

## Extending the CurrentUser Definition

Update the CurrentUser record to include additional claims such as nationality and date of birth.

```csharp
public record CurrentUser(string Id, string Email, IEnumerable<string> Roles, string? Nationality,DateOnly? DateOfBirth)
{
    public bool IsInRole(string role) => Roles.Contains(role);
}
```

This ensures the authorization handler has the necessary user data for validation.

---

## Updating UserContext

Extract the required claims from the authenticated user.

```csharp
var userId = user.FindFirst(c => c.Type == ClaimTypes.NameIdentifier)!.Value;
        var email = user.FindFirst(c => c.Type == ClaimTypes.Email)!.Value;
        var roles = user.Claims.Where(c => c.Type == ClaimTypes.Role)!.Select(c => c.Value);
        var nationality = user.FindFirst(c => c.Type == "Nationality")?.Value;
        var dateOfBirthString = user.FindFirst(c => c.Type == "DateOfBirth")?.Value;
        var dateOfBirth = dateOfBirthString == null
            ? (DateOnly?) null
            : DateOnly.ParseExact(dateOfBirthString, "yyyy-MM-dd");
        
        return new CurrentUser(userId, email, roles, nationality, dateOfBirth);
```

---

## Registering the Policy

Configure authorization policies in ServiceCollectionExtensions.cs.

```csharp
services.AddAuthorizationBuilder()
            .AddPolicy(PolicyNames.HasNationality, 
                builder => builder.RequireClaim(AppClaimTypes.Nationality))
            .AddPolicy(PolicyNames.AtLeast20,
                builder => builder.AddRequirements(new MinimumAgeRequirement(20)));
        services.AddScoped<IAuthorizationHandler,MinimumAgeRequirementHandler>();
```

Add `AddPolicy` for `AtLeast20` method

Add services.AddScoped for our `IAuthorizationHandler` and MinimumAgeRequirementHandler

Key Points:
- AddPolicy defines the authorization rule. 
- AddRequirements attaches the custom requirement. 
- IAuthorizationHandler registers the handler with the dependency injection container.

## How To Test

We add a breakpoint to our DishController in GetAllForRestaurant endpoint

Protect an endpoint by attaching the policy:
```csharp
[Authorize(Policy = PolicyNames.AtLeast20)]
```

Try using `Swagger` or `Restaurant.Api.http`

### Test using these 2 account:
Set owner@gmail.com to have DateOfBirth = "2010-01-01" and Nationality = "Malaysia" in our database 

Result:
```json
[06:02:2026 23:36:42 INF] User: owner@gmail.com, date of birth 01/01/2010 - Handling MinimumAgeRequirement

```

✅ Access is denied because the minimum age requirement is not met.

---

Set testuser2@gmail.com to have DateOfBirth = "2004-02-02" and Nationality = "Malaysia" in our database

Result:
```json
{
    "id": 1,
    "name": "Snack Plate",
    "description": "Chicken and coslo",
    "price": 10,
    "kiloCalories": null
  },
  {
    "id": 2,
    "name": "Chicken Tender",
    "description": "Chicken and water",
    "price": 14,
    "kiloCalories": null
  }
```

✅ Authorized User

Database Values:
- Email: testuser2@gmail.com 
- DateOfBirth: 2004-02-02 
- Nationality: Malaysia

Result:

The user successfully retrieves the list of dishes.

## Conclusion

Custom authorization enables developers to enforce business-specific security rules while maintaining a clean separation 
between controllers and security logic. By implementing policy-based authorization with requirements and handlers, 
applications become more secure, scalable, and easier to maintain.






